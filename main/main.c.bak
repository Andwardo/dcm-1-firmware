/*
 * File: main/main.c
 *
 * Created on: 10 June 2025 17:55:00
 * Last edited on: 10 June 2025 18:31:00
 *
 * Version: 7.0.3
 *
 * Author: R. Andrew Ballard (c) 2025
 *
 */

#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_log.h"
#include "nvs_flash.h"

// Include our new wifi manager
#include "wifi_manager.h"

// Logging Tag
static const char *TAG = "PIANOGUARD_MAIN";

// --- Pin Definitions for ESP32-S3 ---
#define I2C_SCL_PIN                 GPIO_NUM_6
#define I2C_SDA_PIN                 GPIO_NUM_5
#define I2C_PORT                    I2C_NUM_0
#define I2C_FREQ_HZ                 100000

#define VIBRATION_SENSOR_PIN        GPIO_NUM_35
#define NOLOAD_PADS_PIN             GPIO_NUM_34
#define LOAD_PADS_PIN               GPIO_NUM_39
#define NOLOAD_WATER_PIN            GPIO_NUM_36
#define LOAD_WATER_PIN              GPIO_NUM_7
#define NOLOAD_POWER_PIN            GPIO_NUM_26
#define LOAD_POWER_PIN              GPIO_NUM_27
#define STATUS_LED_PIN              GPIO_NUM_2
#define WIFI_RESET_PIN              GPIO_NUM_4

static void configure_pins(void)
{
    // --- Configure Input Pins ---
    gpio_config_t input_config = {
        .pin_bit_mask = (1ULL << VIBRATION_SENSOR_PIN) |
                        (1ULL << NOLOAD_PADS_PIN)    | (1ULL << LOAD_PADS_PIN) |
                        (1ULL << NOLOAD_WATER_PIN)   | (1ULL << LOAD_WATER_PIN) |
                        (1ULL << NOLOAD_POWER_PIN)   | (1ULL << LOAD_POWER_PIN),
        .mode = GPIO_MODE_INPUT,
        .pull_up_en = GPIO_PULLUP_DISABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE
    };
    gpio_config(&input_config);

    // --- Configure WiFi Reset Button ---
    gpio_config_t button_config = {
        .pin_bit_mask = (1ULL << WIFI_RESET_PIN),
        .mode = GPIO_MODE_INPUT,
        .pull_up_en = GPIO_PULLUP_ENABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE
    };
    gpio_config(&button_config);

    // --- Configure Output Pins ---
    gpio_config_t output_config = {
        .pin_bit_mask = (1ULL << STATUS_LED_PIN),
        .mode = GPIO_MODE_OUTPUT,
        .pull_up_en = GPIO_PULLUP_DISABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE
    };
    gpio_config(&output_config);
    ESP_LOGI(TAG, "All GPIO pins configured for ESP32-S3.");
}

static void configure_i2c(void)
{
    // ... (rest of the function is unchanged)
    i2c_config_t i2c_conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = I2C_SDA_PIN,
        .scl_io_num = I2C_SCL_PIN,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = I2C_FREQ_HZ,
    };
    esp_err_t err = i2c_param_config(I2C_PORT, &i2c_conf);
    if (err != ESP_OK) { ESP_LOGE(TAG, "I2C param config failed. Code: 0x%x", err); return; }
    err = i2c_driver_install(I2C_PORT, i2c_conf.mode, 0, 0, 0);
    if (err != ESP_OK) { ESP_LOGE(TAG, "I2C driver install failed. Code: 0x%x", err); return; }
    ESP_LOGI(TAG, "I2C master driver initialized.");
}


void app_main(void)
{
    ESP_LOGI(TAG, "PianoGuard DCM-1 Starting Up...");
    
    // Initialize NVS Flash
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    configure_pins();
    configure_i2c();

    // Check if the reset button is pressed on boot
    bool reset_provisioning = (gpio_get_level(WIFI_RESET_PIN) == 0);
    if (reset_provisioning) {
        ESP_LOGW(TAG, "Reset button pressed. Forcing provisioning mode.");
    }

    // Start the wifi manager
    wifi_manager_start(reset_provisioning);

    ESP_LOGI(TAG, "Wi-Fi Connected. Starting main application loop.");

    int led_state = 0;
    while(1) {
        // Toggle the LED
        gpio_set_level(STATUS_LED_PIN, led_state);
        led_state = !led_state;

        // Read one of the input pins to verify it's working
        int vibration_level = gpio_get_level(VIBRATION_SENSOR_PIN);
        ESP_LOGI(TAG, "Vibration Sensor Level: %d", vibration_level);

        // Delay for 1 second
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

